# constants
proc MODELSIM_ERROR {} { return 1 }
proc LEGUP_ERROR {} { return 2 }
proc SONIC_ERROR {} { return 3}

# expect that modelsim will give an error
# see unaligned/ for example
proc run-test-modelsim-error { test expected} {
    run-test $test $expected [MODELSIM_ERROR]
}

proc run-test-legup-error { test expected} {
    run-test $test $expected [LEGUP_ERROR]
}

# test an example:
# 1) compile verilog to cpp 
# 2) compile cpp to executable
# 3) run exe
# 4) check for warnings/errors if expect_error = 0 (default)
# 5) check for expected output

proc run-test-gx { test gxexpected {expect_error 0}} {
    eval exec "make cleantiger"
    set output [run-cmd $test "make emultest"]
    run-regexp "gxemul simulation. Expected: $gxexpected" $gxexpected $output
}

proc run-test-full { test expected gxexpected {expect_error 0}} {

    set ::env(NO_OPT) 0
    set ::env(NO_INLINE) 1

    run-test $test $expected
    run-test-gx $test $gxexpected

    set ::env(NO_OPT) 1

    run-test $test $expected
    run-test-gx $test $gxexpected

    unset ::env(NO_INLINE)
    unset ::env(NO_OPT)
}

proc run-verilator { test expected {expect_error 0} } {
    eval exec "make clean"
    eval exec "make verilator"
    
    # change directory to generated code
    cd obj_dir

    # build test executable
    set output [run-cmd "Build V$test" "make -j -f V$test.mk V$test" $expect_error]

    set output [run-cmd "Execute V$test" "./V$test"]
    
    run-regexp "Verilator simulation. Expected: $expected" $expected $output

    cd ..
}

proc run-test { test expected {expect_error 0} } {

#    if { $expect_error == [LEGUP_ERROR] } {
#        set allow_stderr 1
#        set output [run-cmd $test "make" $allow_stderr]
#        run-regexp "Error expected: $expected" $expected $output
#        # legup is expected to fail so skip modelsim 
#        return
#    } 

#    if { $expect_error != [SONIC_ERROR] } {
#        run-no-regexp "Compile errors" "Error" $make_log
#    }
    

#    if { $expect_error != [MODELSIM_ERROR] } {
#        run-no-regexp "Modelsim warnings" "Warning" $output
#        run-no-regexp "Modelsim errors" "Error" $output
#    }

#    run-regexp "Modelsim simulation. Expected: $expected" $expected $output
}

proc run-regexp { test regexp var} {
    if [regexp $regexp $var] {
        pass "$test"
    } else {
        fail "$test"
    }
}

# make sure regular expression does NOT match
proc run-no-regexp { test regexp var} {
    if [regexp $regexp $var] {
        fail "$test"
    } else {
        pass "$test"
    }
}

proc run-cmd { test cmd {allow_stderr 0}} {
  set status 0
  set resultmsg ""
  set retval [ catch { eval exec -keepnewline -- "$cmd" } errmsg ]
  if { $retval != 0 } {
    set code [lindex $::errorCode 0]
    switch "$code" {
      CHILDSTATUS {
        set status [lindex $::errorCode 2]
        if { $status != 0 } {
          set resultmsg "$test\nFailed with exit($status)$errmsg"
        }
      }
      CHILDKILLED {
        set signal [lindex $::errorCode 2]
        set resultmsg "$test\nFailed with signal($signal)$errmsg"
      }
      CHILDSUSP {
        set signal [lindex $::errorCode 2]
        set resultmsg "$test\nFailed with suspend($signal)$errmsg"
      }
      POSIX {
        set posixNum [lindex $::errorCode 1]
        set posixMsg [lindex $::errorCode 2]
        set resultmsg "$test\nFailed with posix($posixNum,$posixMsg)$errmsg"
      }
      NONE {
        # Any other error such as stderr output of a program, or syntax error in
        # the cmd
        set resultmsg "$test\nFailed with unknown error (or has stderr output)$errmsg"
      }
      default {
        set resultmsg "$test\nFailed with unknown error$errmsg"
      }
    }
  }

  if { $resultmsg != "" && $allow_stderr == 0} {
    fail $resultmsg
  } else {
    pass $test
  }

  verbose "$errmsg" 1
  return "$errmsg"
}

